from queue import PriorityQueue
import time

def get_neighbors(state):
    neighbors = []
    zero_index = state.index(0)
    x, y = divmod(zero_index, 3)
    moves = ((-1, 0), (1, 0), (0, -1), (0, 1)) # Up, Down, Left, Right

    for dx, dy in moves:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_zero = nx * 3 + ny
            new_state = list(state)
            new_state[zero_index], new_state[new_zero] = new_state[new_zero], new_state[zero_index]
            neighbors.append(tuple(new_state))
    return neighbors


def misplaced_tiles(state, goal):
    return sum(1 for i in range(9) if state[i] != 0 and state[i] != goal[i])

def manhattan_distance(state, goal):
    distance = 0
    for i, tile in enumerate(state):
        if tile != 0:
            gx, gy = divmod(goal.index(tile), 3)
            sx, sy = divmod(i, 3)
            distance += abs(gx - sx) + abs(gy - sy)
    return distance

def weighted_manhattan(state, goal):
    return manhattan_distance(state, goal) + misplaced_tiles(state, goal) * 0.5


def a_star_8_puzzle(start, goal, heuristic):
    pq = PriorityQueue()
    pq.put((heuristic(start, goal), [start], 0)) # f = g + h
    visited = set()
    step_counter = 0

    while not pq.empty():
        f, path, g = pq.get()
        state = path[-1]

        if state in visited:
            continue
        visited.add(state)
        step_counter += 1

        if state == goal:
            return path, g, step_counter

        for neighbor in get_neighbors(state):
            if neighbor not in visited:
                new_g = g + 1
                new_f = new_g + heuristic(neighbor, goal)
                pq.put((new_f, path + [neighbor], new_g))

    return None, None, step_counter

goal_state = (1, 2, 3, 4, 5, 6, 7, 8, 0)

initial_states = [
    (1, 2, 3, 4, 0, 5, 6, 7, 8),
    (1, 2, 3, 4, 5, 6, 0, 7, 8),
    (1, 2, 3, 4, 5, 6, 8, 7, 0),
    (1, 3, 4, 8, 6, 2, 7, 0, 5),
    (2, 8, 1, 0, 4, 3, 7, 6, 5)
]

heuristics = {
    "Misplaced Tiles": misplaced_tiles,
    "Manhattan Distance": manhattan_distance,
    "Weighted Manhattan": weighted_manhattan
}

print(f"\n=== A* Heuristic Comparison for 8-Puzzle ===\n")
print(f"{'Initial State':<30} {'Heuristic':<20} {'Solved':<8} {'Time (s)':<10} {'Nodes Expanded'}")

for start_state in initial_states:
    for h_name, h_func in heuristics.items():
        start_time = time.time()
        path, cost, steps = a_star_8_puzzle(start_state, goal_state, h_func)
        end_time = time.time()

        solved = "Yes" if path else "No"
        duration = round(end_time - start_time, 4)
        print(f"{str(start_state):<30} {h_name:<20} {solved:<8} {duration:<10} {steps}")
